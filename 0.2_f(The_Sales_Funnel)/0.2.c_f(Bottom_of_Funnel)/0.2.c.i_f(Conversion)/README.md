# 0.2.c.i f(Conversion)

**Curvature Lock: The Mathematics of Decision Crystallization**

Prospect Theory, loss aversion, and the Laplacian operator ∇²Φ in purchase decisions.

---

## Abstract

Conversion is the **curvature lock** in the collapse stack. The gradient exists (∇Φ), the memory loop circulates (∇×F), the writability gate passed (W=1)—now the field curvature must lock (∇²Φ). This transforms consideration into commitment through the mathematics of decision psychology, where loss aversion coefficients and reference-dependent valuation determine collapse permission.

---

## Part 1: The Curvature Lock Equation

### Core Definition

```
f(Conversion) = ∇²Φ → Curvature_Lock
```

Where:
- **∇²Φ** = Laplacian of intent field (curvature)
- **+∇²Φ > 0** = Expansion mode (still considering)
- **-∇²Φ < 0** = Compression mode (decision crystallizing)
- **∇²Φ = constant** = Lock achieved (conversion imminent)

### The Lock Condition

```
Conversion_ready = ∇²Φ stable AND d(∇²Φ)/dt → 0
```

Decision occurs when curvature stops changing—the prospect has committed to a shape.

### Connection to Collapse

From the collapse stack:

```
∇²Φ (3D curvature) → ρ_q (charge lock)

When ∇²Φ locks:
├── Decision becomes irreversible
├── Commitment forms
└── Conversion executes
```

---

## Part 2: Prospect Theory as Field Dynamics

### The Value Function

Kahneman & Tversky's Prospect Theory value function:

```
V(x) = {
    x^α           if x ≥ 0  (gains)
    -λ(-x)^β      if x < 0  (losses)
}

Where:
α ≈ β ≈ 0.88 (diminishing sensitivity)
λ ≈ 2.25 (loss aversion coefficient)
```

### Tensor Translation

The value function maps to curvature:

```
∇²Φ_gains = d²V/dx² |_{x>0} = α(α-1)x^{α-2}

∇²Φ_losses = d²V/dx² |_{x<0} = -λβ(β-1)(-x)^{β-2}
```

### Loss Aversion in Tensor Terms

```
|∇²Φ_losses| / |∇²Φ_gains| ≈ λ ≈ 2.25

Losses curve the field 2.25x more than equivalent gains.
```

---

## Part 3: Reference Dependence

### The Reference Point

All valuation is relative to a reference point r:

```
ΔΦ = Φ(outcome) - Φ(reference)

V(outcome | reference) = V(ΔΦ)
```

### Reference Point Dynamics in Sales

| Reference | Source | Implication |
|-----------|--------|-------------|
| Current state | Status quo | Change framed as gain or loss |
| Competitor price | Market anchor | Your price feels cheap or expensive |
| List price | Seller anchor | Discount feels like gain |
| Aspirational state | Customer vision | Gap to close |
| Previous offer | Negotiation history | Movement matters |

### Shifting the Reference

```
∇Φ_perceived = ∇Φ_actual - ∇Φ_reference

Control reference → control perceived gradient
```

**Marketing implication:** Anchor high, then present actual price as gain from reference.

---

## Part 4: The Decision Architecture

### ICHTB Fans in Conversion

| Fan | Operator | Conversion Role |
|-----|----------|-----------------|
| Δ₃ (+X) | +∇²Φ | Expansion: Considering options |
| Δ₄ (-X) | -∇²Φ | Compression: Narrowing to choice |
| Δ₅ (+Z) | ∂Φ/∂t | Timing: Decision crystallization |
| Δ₆ (-Z) | Φ = i₀ | Anchor: Core intent verified |

### The Conversion Sequence

```
Phase 1: +∇²Φ > 0 (Expansion)
├── Exploring options
├── Gathering information
└── Curvature positive (outward)

Phase 2: ∇²Φ → 0 (Inflection)
├── Options narrowed
├── Preferences forming
└── Curvature flattening

Phase 3: -∇²Φ < 0 (Compression)
├── Decision crystallizing
├── Commitment forming
└── Curvature negative (inward)

Phase 4: d(∇²Φ)/dt = 0 (Lock)
├── Curvature stable
├── Decision made
└── Conversion executes
```

---

## Part 5: The Conversion Probability Function

### Gaussian Collapse

```
P_conversion(x) = exp(-(ΔΨ)² / 2σ²)
```

Where ΔΨ = gap between customer intent and offer.

### Prospect Theory Augmented

Incorporating loss aversion:

```
P_conversion = exp(-[λ·L(ΔΨ) + G(ΔΨ)]² / 2σ²)

Where:
L(ΔΨ) = Loss component (price, risk, change cost)
G(ΔΨ) = Gain component (benefits, value, improvement)
λ = 2.25 (loss aversion multiplier)
```

### The Conversion Threshold

```
Conversion occurs when:
G(ΔΨ) > λ · L(ΔΨ)

Or equivalently:
Perceived_value > 2.25 × Perceived_cost
```

---

## Part 6: The Certainty Effect

### Definition

Kahneman-Tversky certainty effect:

```
π(p) ≠ p

Where:
π(p) = Decision weight (how probabilities feel)
p = Objective probability
```

### Decision Weight Function

```
π(p) = p^γ / [p^γ + (1-p)^γ]^{1/γ}

Where γ ≈ 0.65
```

### Implications for Conversion

| Probability | Decision Weight | Marketing Implication |
|-------------|----------------|----------------------|
| p = 0.01 | π = 0.05 | Rare events overweighted (lottery effect) |
| p = 0.10 | π = 0.17 | Risks feel larger |
| p = 0.50 | π = 0.42 | Uncertainty underweighted |
| p = 0.90 | π = 0.71 | Near-certainty underweighted |
| p = 0.99 | π = 0.91 | Guarantees > near-guarantees |

### Certainty Premium

```
V(guaranteed) > π(0.99) · V(almost_guaranteed)

Guarantees disproportionately valuable.
```

**Marketing implication:** Money-back guarantees, satisfaction guarantees, performance guarantees all leverage the certainty effect.

---

## Part 7: Endowment and Status Quo

### The Endowment Effect

```
WTA / WTP ≈ 2.0-3.0

Where:
WTA = Willingness to accept (selling price)
WTP = Willingness to pay (buying price)
```

Once owned, value increases 2-3x.

### Tensor Translation

```
∇²Φ_owned < ∇²Φ_not_owned

Ownership creates compression lock—harder to reverse.
```

### Status Quo Bias

```
Utility(current_state) = U(x) + k

Where k = Status quo premium
```

The default option has automatic advantage.

### Leveraging Endowment

| Strategy | Mechanism | Implementation |
|----------|-----------|----------------|
| Free trial | Create ownership | 30-day trial period |
| Freemium | Partial ownership | Free tier with upgrade |
| Demo access | Simulated ownership | Sandbox environment |
| Take-home | Physical ownership | Product samples |

---

## Part 8: Framing Effects

### Gain vs Loss Framing

Same objective outcome, different perception:

```
Frame_gain: "Save $100"
Frame_loss: "Don't lose $100"

V(frame_loss) = λ · V(frame_gain) ≈ 2.25 × response
```

### Application to Conversion Messaging

| Gain Frame | Loss Frame | Lift |
|------------|------------|------|
| "Save 20% on bills" | "Stop losing 20% on bills" | +47% |
| "Get faster results" | "Stop wasting time" | +35% |
| "Improve efficiency" | "Eliminate inefficiency" | +28% |

### The Optimal Frame

```
If prospect in gain zone (above reference):
    Use gain framing (they're risk-averse)

If prospect in loss zone (below reference):
    Use loss framing (they're risk-seeking)
```

---

## Part 9: Anchoring and Adjustment

### The Anchoring Effect

```
Estimate(x) = Anchor + Insufficient_adjustment

Adjustment ≈ 0.3-0.5 of required adjustment
```

### Price Anchoring

```
Perceived_value = Anchor - Actual_price

High anchor → price feels like deal
Low anchor → price feels expensive
```

### Anchoring Strategies

| Strategy | Anchor | Effect |
|----------|--------|--------|
| List price first | MSRP | Discount feels like gain |
| Premium tier first | High option | Standard feels reasonable |
| Competitor comparison | Competitor price | Your price positioned |
| Total cost of problem | Pain cost | Solution is cheap |
| ROI projection | Future value | Price is investment |

### The Decoy Effect

```
Options = {A, B, Decoy}

Where Decoy is dominated by B but not A.

Result: B choice share increases.
```

Classic three-tier pricing leverages this.

---

## Part 10: The Conversion Rate Equation

### Core Formula

```
Conversion_rate = Writables × P_collapse × (1 - Friction)

Where:
Writables = W(x) filtered leads
P_collapse = exp(-(ΔΨ)²/2σ²)
Friction = Barriers in conversion path
```

### Friction Components

```
Friction = f(form_fields) + f(payment_steps) + f(cognitive_load) + f(trust_gaps)
```

| Friction Source | Impact | Mitigation |
|-----------------|--------|------------|
| Form fields | -11% per field | Minimize fields |
| Payment steps | -20% per step | One-click checkout |
| Cognitive load | -15% per decision | Pre-fill, defaults |
| Trust gaps | -30% if present | Guarantees, reviews |

### Conversion Rate Optimization

```
Maximize: CR = W · P · (1 - F)

Levers:
├── W: Better qualification (upstream)
├── P: Better offer-intent fit
└── F: Reduce friction (UX/process)
```

---

## Part 11: Implementation Architecture

### The Conversion Engine

```python
class ConversionEngine:
    """
    Curvature lock computation: ∇²Φ → Conversion
    Incorporates Prospect Theory dynamics.
    """

    def __init__(self, config: Config):
        self.lambda_loss = config.loss_aversion  # ~2.25
        self.alpha = config.gain_sensitivity  # ~0.88
        self.beta = config.loss_sensitivity  # ~0.88
        self.gamma = config.probability_weight  # ~0.65

    def compute_value(self, outcome: float, reference: float) -> float:
        """
        Prospect Theory value function.
        V(x) = x^α for gains, -λ(-x)^β for losses
        """
        delta = outcome - reference

        if delta >= 0:
            return delta ** self.alpha
        else:
            return -self.lambda_loss * ((-delta) ** self.beta)

    def compute_curvature(self, lead: Lead, offer: Offer) -> CurvatureResult:
        """
        ∇²Φ computation for conversion readiness.
        """
        # Compute gain/loss components
        gains = self.compute_gains(lead, offer)
        losses = self.compute_losses(lead, offer)

        # Apply loss aversion
        weighted_value = gains - self.lambda_loss * losses

        # Compute curvature (second derivative of value)
        curvature = self.second_derivative_value(weighted_value)

        # Determine phase
        if curvature > 0:
            phase = 'expansion'
        elif curvature < 0:
            phase = 'compression'
        else:
            phase = 'lock'

        # Compute stability
        stability = self.curvature_stability(lead)

        return CurvatureResult(
            curvature=curvature,
            phase=phase,
            stability=stability,
            conversion_ready=(phase == 'lock' or
                            (phase == 'compression' and stability > 0.8)),
            value_gap=weighted_value
        )

    def compute_gains(self, lead: Lead, offer: Offer) -> float:
        """
        Total perceived gains from offer.
        """
        gains = 0.0
        gains += offer.time_savings * lead.time_value
        gains += offer.cost_savings
        gains += offer.revenue_increase * lead.revenue_sensitivity
        gains += offer.risk_reduction * lead.risk_aversion
        return gains

    def compute_losses(self, lead: Lead, offer: Offer) -> float:
        """
        Total perceived losses from conversion.
        """
        losses = 0.0
        losses += offer.price
        losses += lead.switching_cost
        losses += lead.implementation_effort * lead.effort_sensitivity
        losses += lead.perceived_risk
        return losses

    def conversion_probability(self, lead: Lead, offer: Offer) -> float:
        """
        P_conversion = exp(-(ΔΨ)²/2σ²) adjusted for Prospect Theory
        """
        curvature = self.compute_curvature(lead, offer)

        if curvature.value_gap <= 0:
            # Losses exceed gains (after λ weighting)
            return 0.0

        # Compute ΔΨ
        delta_psi = self.compute_intent_gap(lead, offer)

        # Gaussian collapse probability
        sigma = lead.tolerance
        p_collapse = math.exp(-(delta_psi ** 2) / (2 * sigma ** 2))

        # Apply certainty effect if guarantees present
        if offer.has_guarantee:
            p_collapse *= 1.15  # Certainty premium

        return min(p_collapse, 1.0)
```

### Framing Optimizer

```python
class FramingOptimizer:
    """
    Select optimal message framing based on prospect position.
    """

    def __init__(self, lambda_loss: float = 2.25):
        self.lambda_loss = lambda_loss

    def determine_frame(self, lead: Lead) -> FrameType:
        """
        Gain frame if above reference (risk-averse).
        Loss frame if below reference (risk-seeking).
        """
        position = self.compute_reference_position(lead)

        if position >= 0:
            return FrameType.GAIN
        else:
            return FrameType.LOSS

    def generate_messaging(
        self,
        lead: Lead,
        offer: Offer
    ) -> Dict[str, str]:
        """
        Generate framed messaging for conversion.
        """
        frame = self.determine_frame(lead)

        if frame == FrameType.GAIN:
            return {
                'headline': f"Save {offer.savings} annually",
                'cta': "Start saving today",
                'urgency': "Lock in these savings",
                'proof': f"Join {offer.customer_count} who improved results"
            }
        else:
            return {
                'headline': f"Stop losing {offer.savings} annually",
                'cta': "Stop the waste today",
                'urgency': "Every day costs you more",
                'proof': f"{offer.customer_count} stopped losing money"
            }

    def compute_anchor(
        self,
        offer: Offer,
        strategy: AnchorStrategy
    ) -> float:
        """
        Compute optimal price anchor.
        """
        if strategy == AnchorStrategy.LIST_PRICE:
            return offer.list_price
        elif strategy == AnchorStrategy.COMPETITOR:
            return offer.competitor_price
        elif strategy == AnchorStrategy.PROBLEM_COST:
            return offer.annual_problem_cost
        elif strategy == AnchorStrategy.ROI:
            return offer.projected_value
        else:
            return offer.price * 1.5  # Default 50% above
```

---

## Part 12: Validation Metrics

### Conversion Metrics

| Metric | Equation | Target |
|--------|----------|--------|
| Conversion rate | Conversions / Opportunities | Industry-specific |
| Value/Conversion | Revenue / Conversions | Increasing |
| Time to conversion | t(opportunity → close) | Decreasing |
| Curvature velocity | d(∇²Φ)/dt | Toward lock |
| Loss ratio | Lost / (Won + Lost) | Decreasing |

### Prospect Theory Validation

```
Test: A/B framing experiments

Hypothesis: Loss frame outperforms gain frame by ~λ

Measure: Conversion rate by frame type
Expected: Loss_CR / Gain_CR ≈ 1.5-2.0
```

### Drift Detection

```
D_conversion = Actual_CR / Expected_CR

If D < 0.8: Offer-intent mismatch or friction increased
If D > 1.2: Qualification too tight or market shift
```

---

## Part 13: Connection to Master Equation

### Conversion in f(x)

```
f(x) = W(Φ,Ψ,ε) · γᵗ · ∫₀ᵗ A(u,m,τ) dτ
```

Conversion is where the **integral accumulates to threshold**:

```
∫₀ᵗ A dτ > θ_conversion

When this holds AND W(x) = 1 AND ∇²Φ locked:
    Collapse executes
```

### The Collapse Moment

```
t_conversion = argmin{t : ∫₀ᵗ A dτ > θ AND ∇²Φ stable}

Everything before: consideration
Everything after: customer
```

### Value Realization

```
V_realized = f(x) |_{t=t_conversion}

           = W · γ^{t_conversion} · ∫₀^{t_conversion} A dτ
```

---

## Part 14: Summary

### The Conversion Principle

> **Conversion occurs when field curvature locks (∇²Φ stable), meaning the decision has crystallized and commitment forms.**

### The Core Equations

1. **Value function:** V(x) = x^α for gains, -λ(-x)^β for losses
2. **Loss aversion:** λ ≈ 2.25 (losses hurt 2.25x more)
3. **Conversion threshold:** Gains > λ × Losses
4. **Curvature lock:** ∇²Φ stable, d(∇²Φ)/dt → 0
5. **Probability:** P = exp(-(ΔΨ)²/2σ²) × Certainty_premium

### The Action

**Frame for loss aversion, anchor high, lock the curvature.**

---

## References

- Kahneman, D. & Tversky, A. (1979). Prospect Theory. Econometrica.
- Thaler, R. (1980). Toward a Positive Theory of Consumer Choice.
- Knight, A. & Khan, A. (2025). The Funnel Function.
- Intent Tensor Theory. https://intent-tensor-theory.com/

---

## License

Creative Commons Attribution-NonCommercial 4.0 International License

Created by Armstrong Knight & Abdullah Khan
